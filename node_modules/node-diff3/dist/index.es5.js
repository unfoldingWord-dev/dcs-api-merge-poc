(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.Diff3 = {}));
}(this, (function (exports) { 'use strict';

// Text diff algorithm following Hunt and McIlroy 1976.
// J. W. Hunt and M. D. McIlroy, An algorithm for differential buffer
// comparison, Bell Telephone Laboratories CSTR #41 (1976)
// http://www.cs.dartmouth.edu/~doug/
// https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
//
// Expects two arrays, finds longest common sequence
function LCS(buffer1, buffer2) {

  var equivalenceClasses = {};
  for (var j = 0; j < buffer2.length; j++) {
    var item = buffer2[j];
    if (equivalenceClasses[item]) {
      equivalenceClasses[item].push(j);
    } else {
      equivalenceClasses[item] = [j];
    }
  }

  var NULLRESULT = { buffer1index: -1, buffer2index: -1, chain: null };
  var candidates = [NULLRESULT];

  for (var i = 0; i < buffer1.length; i++) {
    var item$1 = buffer1[i];
    var buffer2indices = equivalenceClasses[item$1] || [];
    var r = 0;
    var c = candidates[0];

    for (var jx = 0; jx < buffer2indices.length; jx++) {
      var j$1 = buffer2indices[jx];

      var s = (void 0);
      for (s = r; s < candidates.length; s++) {
        if ((candidates[s].buffer2index < j$1) && ((s === candidates.length - 1) || (candidates[s + 1].buffer2index > j$1))) {
          break;
        }
      }

      if (s < candidates.length) {
        var newCandidate = { buffer1index: i, buffer2index: j$1, chain: candidates[s] };
        if (r === candidates.length) {
          candidates.push(c);
        } else {
          candidates[r] = c;
        }
        r = s + 1;
        c = newCandidate;
        if (r === candidates.length) {
          break; // no point in examining further (j)s
        }
      }
    }

    candidates[r] = c;
  }

  // At this point, we know the LCS: it's in the reverse of the
  // linked-list through .chain of candidates[candidates.length - 1].

  return candidates[candidates.length - 1];
}


// We apply the LCS to build a 'comm'-style picture of the
// differences between buffer1 and buffer2.
function diffComm(buffer1, buffer2) {
  var lcs = LCS(buffer1, buffer2);
  var result = [];
  var tail1 = buffer1.length;
  var tail2 = buffer2.length;
  var common = {common: []};

  function processCommon() {
    if (common.common.length) {
      common.common.reverse();
      result.push(common);
      common = {common: []};
    }
  }

  for (var candidate = lcs; candidate !== null; candidate = candidate.chain) {
    var different = {buffer1: [], buffer2: []};

    while (--tail1 > candidate.buffer1index) {
      different.buffer1.push(buffer1[tail1]);
    }

    while (--tail2 > candidate.buffer2index) {
      different.buffer2.push(buffer2[tail2]);
    }

    if (different.buffer1.length || different.buffer2.length) {
      processCommon();
      different.buffer1.reverse();
      different.buffer2.reverse();
      result.push(different);
    }

    if (tail1 >= 0) {
      common.common.push(buffer1[tail1]);
    }
  }

  processCommon();

  result.reverse();
  return result;
}


// We apply the LCS to give a simple representation of the
// offsets and lengths of mismatched chunks in the input
// buffers. This is used by diff3MergeRegions.
function diffIndices(buffer1, buffer2) {
  var lcs = LCS(buffer1, buffer2);
  var result = [];
  var tail1 = buffer1.length;
  var tail2 = buffer2.length;

  for (var candidate = lcs; candidate !== null; candidate = candidate.chain) {
    var mismatchLength1 = tail1 - candidate.buffer1index - 1;
    var mismatchLength2 = tail2 - candidate.buffer2index - 1;
    tail1 = candidate.buffer1index;
    tail2 = candidate.buffer2index;

    if (mismatchLength1 || mismatchLength2) {
      result.push({
        buffer1: [tail1 + 1, mismatchLength1],
        buffer1Content: buffer1.slice(tail1 + 1, tail1 + 1 + mismatchLength1),
        buffer2: [tail2 + 1, mismatchLength2],
        buffer2Content: buffer2.slice(tail2 + 1, tail2 + 1 + mismatchLength2)
      });
    }
  }

  result.reverse();
  return result;
}


// We apply the LCS to build a JSON representation of a
// diff(1)-style patch.
function diffPatch(buffer1, buffer2) {
  var lcs = LCS(buffer1, buffer2);
  var result = [];
  var tail1 = buffer1.length;
  var tail2 = buffer2.length;

  function chunkDescription(buffer, offset, length) {
    var chunk = [];
    for (var i = 0; i < length; i++) {
      chunk.push(buffer[offset + i]);
    }
    return {
      offset: offset,
      length: length,
      chunk: chunk
    };
  }

  for (var candidate = lcs; candidate !== null; candidate = candidate.chain) {
    var mismatchLength1 = tail1 - candidate.buffer1index - 1;
    var mismatchLength2 = tail2 - candidate.buffer2index - 1;
    tail1 = candidate.buffer1index;
    tail2 = candidate.buffer2index;

    if (mismatchLength1 || mismatchLength2) {
      result.push({
        buffer1: chunkDescription(buffer1, candidate.buffer1index + 1, mismatchLength1),
        buffer2: chunkDescription(buffer2, candidate.buffer2index + 1, mismatchLength2)
      });
    }
  }

  result.reverse();
  return result;
}


// Given three buffers, A, O, and B, where both A and B are
// independently derived from O, returns a fairly complicated
// internal representation of merge decisions it's taken. The
// interested reader may wish to consult
//
// Sanjeev Khanna, Keshav Kunal, and Benjamin C. Pierce.
// 'A Formal Investigation of ' In Arvind and Prasad,
// editors, Foundations of Software Technology and Theoretical
// Computer Science (FSTTCS), December 2007.
//
// (http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf)
//
function diff3MergeRegions(a, o, b) {

  // "hunks" are array subsets where `a` or `b` are different from `o`
  // https://www.gnu.org/software/diffutils/manual/html_node/diff3-Hunks.html
  var hunks = [];
  function addHunk(h, ab) {
    hunks.push({
      ab: ab,
      oStart: h.buffer1[0],
      oLength: h.buffer1[1],   // length of o to remove
      abStart: h.buffer2[0],
      abLength: h.buffer2[1]   // length of a/b to insert
      // abContent: (ab === 'a' ? a : b).slice(h.buffer2[0], h.buffer2[0] + h.buffer2[1])
    });
  }

  diffIndices(o, a).forEach(function (item) { return addHunk(item, 'a'); });
  diffIndices(o, b).forEach(function (item) { return addHunk(item, 'b'); });
  hunks.sort(function (x,y) { return x.oStart - y.oStart; });

  var results = [];
  var currOffset = 0;

  function advanceTo(endOffset) {
    if (endOffset > currOffset) {
      results.push({
        stable: true,
        buffer: 'o',
        bufferStart: currOffset,
        bufferLength: endOffset - currOffset,
        bufferContent: o.slice(currOffset, endOffset)
      });
      currOffset = endOffset;
    }
  }

  while (hunks.length) {
    var hunk = hunks.shift();
    var regionStart = hunk.oStart;
    var regionEnd = hunk.oStart + hunk.oLength;
    var regionHunks = [hunk];
    advanceTo(regionStart);

    // Try to pull next overlapping hunk into this region
    while (hunks.length) {
      var nextHunk = hunks[0];
      var nextHunkStart = nextHunk.oStart;
      if (nextHunkStart > regionEnd) { break; }   // no overlap

      regionEnd = Math.max(regionEnd, nextHunkStart + nextHunk.oLength);
      regionHunks.push(hunks.shift());
    }

    if (regionHunks.length === 1) {
      // Only one hunk touches this region, meaning that there is no conflict here.
      // Either `a` or `b` is inserting into a region of `o` unchanged by the other.
      if (hunk.abLength > 0) {
        var buffer = (hunk.ab === 'a' ? a : b);
        results.push({
          stable: true,
          buffer: hunk.ab,
          bufferStart: hunk.abStart,
          bufferLength: hunk.abLength,
          bufferContent: buffer.slice(hunk.abStart, hunk.abStart + hunk.abLength)
        });
      }
    } else {
      // A true a/b conflict. Determine the bounds involved from `a`, `o`, and `b`.
      // Effectively merge all the `a` hunks into one giant hunk, then do the
      // same for the `b` hunks; then, correct for skew in the regions of `o`
      // that each side changed, and report appropriate spans for the three sides.
      var bounds = {
        a: [a.length, -1, o.length, -1],
        b: [b.length, -1, o.length, -1]
      };
      while (regionHunks.length) {
        hunk = regionHunks.shift();
        var oStart = hunk.oStart;
        var oEnd = oStart + hunk.oLength;
        var abStart = hunk.abStart;
        var abEnd = abStart + hunk.abLength;
        var b$1 = bounds[hunk.ab];
        b$1[0] = Math.min(abStart, b$1[0]);
        b$1[1] = Math.max(abEnd, b$1[1]);
        b$1[2] = Math.min(oStart, b$1[2]);
        b$1[3] = Math.max(oEnd, b$1[3]);
      }

      var aStart = bounds.a[0] + (regionStart - bounds.a[2]);
      var aEnd = bounds.a[1] + (regionEnd - bounds.a[3]);
      var bStart = bounds.b[0] + (regionStart - bounds.b[2]);
      var bEnd = bounds.b[1] + (regionEnd - bounds.b[3]);

      var result = {
        stable: false,
        aStart: aStart,
        aLength: aEnd - aStart,
        aContent: a.slice(aStart, aEnd),
        oStart: regionStart,
        oLength: regionEnd - regionStart,
        oContent: o.slice(regionStart, regionEnd),
        bStart: bStart,
        bLength: bEnd - bStart,
        bContent: b.slice(bStart, bEnd)
      };
      results.push(result);
    }
    currOffset = regionEnd;
  }

  advanceTo(o.length);

  return results;
}


// Applies the output of diff3MergeRegions to actually
// construct the merged buffer; the returned result alternates
// between 'ok' and 'conflict' blocks.
// A "false conflict" is where `a` and `b` both change the same from `o`
function diff3Merge(a, o, b, options) {
  var defaults = {
    excludeFalseConflicts: true,
    stringSeparator: /\s+/
  };
  options = Object.assign(defaults, options);

  var aString = (typeof a === 'string');
  var oString = (typeof o === 'string');
  var bString = (typeof b === 'string');

  if (aString) { a = a.split(options.stringSeparator); }
  if (oString) { o = o.split(options.stringSeparator); }
  if (bString) { b = b.split(options.stringSeparator); }

  var results = [];
  var regions = diff3MergeRegions(a, o, b);

  var okBuffer = [];
  function flushOk() {
    if (okBuffer.length) {
      results.push({ ok: okBuffer });
    }
    okBuffer = [];
  }

  function isFalseConflict(a, b) {
    if (a.length !== b.length) { return false; }
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) { return false; }
    }
    return true;
  }

  regions.forEach(function (region) {
    if (region.stable) {
      okBuffer.push.apply(okBuffer, region.bufferContent);
    } else {
      if (options.excludeFalseConflicts && isFalseConflict(region.aContent, region.bContent)) {
        okBuffer.push.apply(okBuffer, region.aContent);
      } else {
        flushOk();
        results.push({
          conflict: {
            a: region.aContent,
            aIndex: region.aStart,
            o: region.oContent,
            oIndex: region.oStart,
            b: region.bContent,
            bIndex: region.bStart
          }
        });
      }
    }
  });

  flushOk();
  return results;
}

function mergeDiff3(a, o, b, options) {
  var defaults = {
    excludeFalseConflicts: true,
    stringSeparator: /\s+/,
    label: {}
  };
  options = Object.assign(defaults, options);

  var mergeResult = diff3Merge(a, o, b, options);

  var conflict = false;
  var lines = [];

  mergeResult.forEach(function (result) {
    if (result.ok) {
      lines = lines.concat(result.ok);
    } else if (result.conflict) { 
      conflict = true;
      lines.push(("<<<<<<<" + (options.label.a ? (" " + (options.label.a)) : '')));
      lines = lines.concat(result.conflict.a);
      lines.push(("|||||||" + (options.label.o ? (" " + (options.label.o)) : '')));
      lines = lines.concat(result.conflict.o);
      lines.push('=======');
      lines = lines.concat(result.conflict.b);
      lines.push((">>>>>>>" + (options.label.b ? (" " + (options.label.b)) : '')));
    }
  });

  return {
    conflict: conflict,
    result: lines
  };
}

function merge(a, o, b, options) {
  var defaults = {
    excludeFalseConflicts: true,
    stringSeparator: /\s+/
  };
  options = Object.assign(defaults, options);

  var merger = diff3Merge(a, o, b, options);
  var conflict = false;
  var lines = [];
  for (var i = 0; i < merger.length; i++) {
    var item = merger[i];
    if (item.ok) {
      lines = lines.concat(item.ok);
    } else {
      conflict = true;
      lines = lines.concat(
        ['\n<<<<<<<<<\n'], item.conflict.a,
        ['\n=========\n'], item.conflict.b,
        ['\n>>>>>>>>>\n']
      );
    }
  }
  return {
    conflict: conflict,
    result: lines
  };
}


function mergeDigIn(a, o, b, options) {
  var defaults = {
    excludeFalseConflicts: false,
    stringSeparator: /\s+/
  };
  options = Object.assign(defaults, options);

  var merger = diff3Merge(a, o, b, options);
  var conflict = false;
  var lines = [];
  for (var i = 0; i < merger.length; i++) {
    var item = merger[i];
    if (item.ok) {
      lines = lines.concat(item.ok);
    } else {
      var c = diffComm(item.conflict.a, item.conflict.b);
      for (var j = 0; j < c.length; j++) {
        var inner = c[j];
        if (inner.common) {
          lines = lines.concat(inner.common);
        } else {
          conflict = true;
          lines = lines.concat(
            ['\n<<<<<<<<<\n'], inner.buffer1,
            ['\n=========\n'], inner.buffer2,
            ['\n>>>>>>>>>\n']
          );
        }
      }
    }
  }
  return {
    conflict: conflict,
    result: lines
  };
}


// Applies a patch to a buffer.
// Given buffer1 and buffer2, `patch(buffer1, diffPatch(buffer1, buffer2))` should give buffer2.
function patch(buffer, patch) {
  var result = [];
  var currOffset = 0;

  function advanceTo(targetOffset) {
    while (currOffset < targetOffset) {
      result.push(buffer[currOffset]);
      currOffset++;
    }
  }

  for (var chunkIndex = 0; chunkIndex < patch.length; chunkIndex++) {
    var chunk = patch[chunkIndex];
    advanceTo(chunk.buffer1.offset);
    for (var itemIndex = 0; itemIndex < chunk.buffer2.chunk.length; itemIndex++) {
      result.push(chunk.buffer2.chunk[itemIndex]);
    }
    currOffset += chunk.buffer1.length;
  }

  advanceTo(buffer.length);
  return result;
}


// Takes the output of diffPatch(), and removes extra information from it. 
// It can still be used by patch(), below, but can no longer be inverted.
function stripPatch(patch) {
  return patch.map(function (chunk) { return ({
    buffer1: { offset: chunk.buffer1.offset, length: chunk.buffer1.length },
    buffer2: { chunk: chunk.buffer2.chunk }
  }); });
}


// Takes the output of diffPatch(), and inverts the sense of it, so that it 
// can be applied to buffer2 to give buffer1 rather than the other way around.
function invertPatch(patch) {
  return patch.map(function (chunk) { return ({ 
    buffer1: chunk.buffer2, 
    buffer2: chunk.buffer1 
  }); });
}

exports.LCS = LCS;
exports.diff3Merge = diff3Merge;
exports.diff3MergeRegions = diff3MergeRegions;
exports.diffComm = diffComm;
exports.diffIndices = diffIndices;
exports.diffPatch = diffPatch;
exports.invertPatch = invertPatch;
exports.merge = merge;
exports.mergeDiff3 = mergeDiff3;
exports.mergeDigIn = mergeDigIn;
exports.patch = patch;
exports.stripPatch = stripPatch;

Object.defineProperty(exports, '__esModule', { value: true });

})));
